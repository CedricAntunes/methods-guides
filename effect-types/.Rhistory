1 Almost every social science experiment faces a multiple comparisons problem
1 Almost every social science experiment faces a multiple comparisons problem
1 Almost every social science experiment faces a multiple comparisons problem
Almost every social science experiment faces a multiple comparisons problem
---
Author: NA
title: 10 Things You Need to Know About Multiple Comparisons
output: pdf_document
---
Abstract
==
The “Multiple Comparisons Problem” is the problem  that standard statistical procedures can be misleading when researchers conduct a large group of hypothesis. When a research has multiple “bites at the apple,” the chances are that some finding will appear “significant” even when there’s nothing going on.
Classical hypothesis tests assess statistical significance by calculating the probability under a null hypothesis of obtaining estimates as large or larger as the observed estimate. When multiple tests are conducted, however, classical p-values are incorrect — they no longer reflect the true probability under the null.
This guide will help you guard against drawing false conclusions from your experiments. We focus on the big ideas and provide examples and tools that you can use in R.
==
The multiple comparisons problem is related to, but different from, the problem of “fishing”.  Fishing occurs when an unscrupulous analyst conducts many tests but only reports the “interesting” ones. In essence, fishing withholds the necessary information we would need in order to correct for multiple comparisons.
---
set.seed(1234) # For replication
n = 1000 # Population size
Y0 = runif(n) # Potential outcome under control condition
Y1= Y0
Y1[Y0 <.5] = Y0[Y0 <.5]-rnorm(length(Y0[Y0 <.5]))
Y1[Y0 >.5] = Y0[Y0 >.5]+rnorm(length(Y0[Y0 >.5]))
(1:n)
(1:n)%%2
sample((1:n)%%2)
D = sample((1:n)%%2) # Treatment: 1 if treated, 0 otherwise Y = D*Y1 + (1-D)*Y0 # Outcome in population
samp = data.frame(D,Y)
samp
samp = data.frame(D,Y)
Y = D*Y1 + (1-D)*Y0 # Outcome in population
samp = data.frame(D,Y)
samp
library(quantreg)
ATE = coef(lm(Y~D,data=samp))[2]
QTE = rq(Y~D,tau =
seq(.05,.95,length.out=10),data=samp,method = "fn")
plot(summary(QTE),parm=2,main="",ylab="QTE",xlab="Quan
tile",mar = c(5.1, 4.1, 2.1, 2.1))
install.packages("mediation")
set.seed(1234) # For replication
n = 1000 # Sample size
X1 = rnorm(n) # Covariates
samp = data.frame(D,Y,X1,X2) # Data frame
set.seed(1234) # For replication
n = 1000 # Sample size
X1 = rnorm(n) # Covariates
X2 = rnorm(n)
p = pnorm(-0.5 + 0.75*X2) # Unequal probability of treatment
D = rbinom(n, 1, p)
p0 = pnorm(rnorm(n)) # Potential outcomes for binary response
p1 = pnorm(X1 + X2+1)
Y0 = rbinom(n, 1, p0)
Y1 = rbinom(n, 1, p1)
Y = D*Y1 + (1-D)*Y0 # Observed outcome
samp = data.frame(D,Y,X1,X2) # Data frame
set.seed(1234) # For replication
n = 1000 # Sample size
X1 = rnorm(n) # Covariates
X2 = rnorm(n)
p = pnorm(-0.5 + 0.75*X2) # Unequal probability of treatment
D = rbinom(n, 1, p)
p0 = pnorm(rnorm(n)) # Potential outcomes for binary response
p1 = pnorm(X1 + X2+1)
Y0 = rbinom(n, 1, p0)
Y1 = rbinom(n, 1, p1)
Y = D*Y1 + (1-D)*Y0 # Observed outcome
samp = data.frame(D,Y,X1,X2) # Data frame
attribute<-function(treat,out,A,data){
# Contingency Table of Treatment Status and Outcome
attr.tab<-with(data,table(treat,out)) #
# Matrix of p-values for Attributable effects, A attr.ps<-
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
for(i in 1:A){
attr.ps[i,]<-
c(i,fisher.test(attr.tab+matrix(c(0,i,0,-i),2,2))$p)
}
set.seed(1234) # For replication
n = 1000 # Sample size
X1 = rnorm(n) # Covariates
X2 = rnorm(n)
p = pnorm(-0.5 + 0.75*X2) # Unequal probability of treatment
D = rbinom(n, 1, p)
p0 = pnorm(rnorm(n)) # Potential outcomes for binary response
p1 = pnorm(X1 + X2+1)
Y0 = rbinom(n, 1, p0)
Y1 = rbinom(n, 1, p1)
Y = D*Y1 + (1-D)*Y0 # Observed outcome
samp = data.frame(D,Y,X1,X2) # Data frame
attribute<-function(treat,out,A,data){
# Contingency Table of Treatment Status and Outcome
attr.tab<-with(data,table(treat,out)) #
# Matrix of p-values for Attributable effects, A attr.ps<-
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
for(i in 1:A){
attr.ps[i,]<-
c(i,fisher.test(attr.tab+matrix(c(0,i,0,-i),2,2))$p)
}
# Find range of effects
get.bounds<-function(){
diffs<-ifelse(.05-attr.ps[,"p"]>0,.05-
attr.ps[,"p"],99)
index<-(diffs %in%
c(min(diffs),min(diffs[diffs>min(diffs)])))
index
}
set.seed(1234) # For replication
n = 1000 # Sample size
X1 = rnorm(n) # Covariates
X2 = rnorm(n)
p = pnorm(-0.5 + 0.75*X2) # Unequal probability of treatment
D = rbinom(n, 1, p)
p0 = pnorm(rnorm(n)) # Potential outcomes for binary response
p1 = pnorm(X1 + X2+1)
Y0 = rbinom(n, 1, p0)
Y1 = rbinom(n, 1, p1)
Y = D*Y1 + (1-D)*Y0 # Observed outcome
samp = data.frame(D,Y,X1,X2) # Data frame
attribute<-function(treat,out,A,data){
# Contingency Table of Treatment Status and Outcome
attr.tab<-with(data,table(treat,out)) #
# Matrix of p-values for Attributable effects, A attr.ps<-
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
for(i in 1:A){
attr.ps[i,]<-
c(i,fisher.test(attr.tab+matrix(c(0,i,0,-i),2,2))$p)
}
# Find range of effects
get.bounds<-function(){
diffs<-ifelse(.05-attr.ps[,"p"]>0,.05-
attr.ps[,"p"],99)
index<-(diffs %in%
c(min(diffs),min(diffs[diffs>min(diffs)])))
index
}
# Return range of effects
return (attr.ps[get.bounds(),])
} with(samp,table(D,Y))
# Return range of effects
return (attr.ps[get.bounds()],)
} with(samp,table(D,Y))
set.seed(1234) # For replication
n = 1000 # Sample size
X1 = rnorm(n) # Covariates
X2 = rnorm(n)
p = pnorm(-0.5 + 0.75*X2) # Unequal probability of treatment
D = rbinom(n, 1, p)
p0 = pnorm(rnorm(n)) # Potential outcomes for binary response
p1 = pnorm(X1 + X2+1)
Y0 = rbinom(n, 1, p0)
Y1 = rbinom(n, 1, p1)
Y = D*Y1 + (1-D)*Y0 # Observed outcome
samp = data.frame(D,Y,X1,X2) # Data frame
attribute<-function(treat,out,A,data){
# Contingency Table of Treatment Status and Outcome
attr.tab<-with(data,table(treat,out)) #
# Matrix of p-values for Attributable effects, A attr.ps<-
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
for(i in 1:A){
attr.ps[i,]<-
c(i,fisher.test(attr.tab+matrix(c(0,i,0,-i),2,2))$p)
}
# Find range of effects
get.bounds<-function(){
diffs<-ifelse(.05-attr.ps[,"p"]>0,.05-
attr.ps[,"p"],99)
index<-(diffs %in%
c(min(diffs),min(diffs[diffs>min(diffs)])))
index
}
# Return range of effects
return (attr.ps[get.bounds()],)
} with(samp,table(D,Y))
set.seed(1234) # For replication
n = 1000 # Sample size
X1 = rnorm(n) # Covariates
X2 = rnorm(n)
p = pnorm(-0.5 + 0.75*X2) # Unequal probability of treatment
D = rbinom(n, 1, p)
p0 = pnorm(rnorm(n)) # Potential outcomes for binary response
p1 = pnorm(X1 + X2+1)
Y0 = rbinom(n, 1, p0)
Y1 = rbinom(n, 1, p1)
Y = D*Y1 + (1-D)*Y0 # Observed outcome
samp = data.frame(D,Y,X1,X2) # Data frame
attribute<-function(treat,out,A,data){
# Contingency Table of Treatment Status and Outcome
attr.tab<-with(data,table(treat,out)) #
# Matrix of p-values for Attributable effects, A attr.ps<-
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
for(i in 1:A){
attr.ps[i,]<-
c(i,fisher.test(attr.tab+matrix(c(0,i,0,-i),2,2))$p)
}
# Find range of effects
get.bounds<-function(){
diffs<-ifelse(.05-attr.ps[,"p"]>0,.05-
attr.ps[,"p"],99)
index<-(diffs %in%
c(min(diffs),min(diffs[diffs>min(diffs)])))
index
}
# Return range of effects
return (attr.ps[get.bounds(),])
}
with(samp,table(D,Y))
set.seed(1234) # For replication
n = 1000 # Sample size
X1 = rnorm(n) # Covariates
X2 = rnorm(n)
p = pnorm(-0.5 + 0.75*X2) # Unequal probability of treatment
D = rbinom(n, 1, p)
p0 = pnorm(rnorm(n)) # Potential outcomes for binary response
p1 = pnorm(X1 + X2+1)
Y0 = rbinom(n, 1, p0)
Y1 = rbinom(n, 1, p1)
Y = D*Y1 + (1-D)*Y0 # Observed outcome
samp = data.frame(D,Y,X1,X2) # Data frame
attribute<-function(treat,out,A,data){
# Contingency Table of Treatment Status and Outcome
attr.tab<-with(data,table(treat,out)) #
# Matrix of p-values for Attributable effects, A attr.ps<-
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
for(i in 1:A){
attr.ps[i,]<-
c(i,fisher.test(attr.tab+matrix(c(0,i,0,-i),2,2))$p)
}
# Find range of effects
get.bounds<-function(){
diffs<-ifelse(.05-attr.ps[,"p"]>0,.05-
attr.ps[,"p"],99)
index<-(diffs %in%
c(min(diffs),min(diffs[diffs>min(diffs)])))
index
}
# Return range of effects
return (attr.ps[get.bounds(),])
}
with(samp,table(D,Y))
with(samp,apply(table(D,Y),1,prop.table))
attribute(treat = D, out= Y, A=200,data=samp)
attribute(treat=D, out=Y, A=200,data=samp)
attribute(treat=D, out=Y, A=200, data=samp)
rm(list=ls())
set.seed(1234) # For replication
n = 1000 # Sample size
X1 = rnorm(n) # Covariates
X2 = rnorm(n)
p = pnorm(-0.5 + 0.75*X2) # Unequal probability of treatment
D = rbinom(n, 1, p)
p0 = pnorm(rnorm(n)) # Potential outcomes for binary response
p1 = pnorm(X1 + X2+1)
Y0 = rbinom(n, 1, p0)
Y1 = rbinom(n, 1, p1)
Y = D*Y1 + (1-D)*Y0 # Observed outcome
Y
samp = data.frame(D,Y,X1,X2) # Data frame
samp
attribute<-function(treat,out,A,data){
# Contingency Table of Treatment Status and Outcome
attr.tab<-with(data,table(treat,out)) #
# Matrix of p-values for Attributable effects, A attr.ps<-
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
for(i in 1:A){
attr.ps[i,]<-
c(i,fisher.test(attr.tab+matrix(c(0,i,0,-i),2,2))$p)
}
attribute<-function(treat,out,A,data){
# Contingency Table of Treatment Status and Outcome
attr.tab<-with(data,table(treat,out)) #
# Matrix of p-values for Attributable effects, A attr.ps<-
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
for(i in 1:A){
attr.ps[i,]<-
c(i,fisher.test(attr.tab+matrix(c(0,i,0,-i),2,2))$p)
}
# Find range of effects
get.bounds<-function(){
diffs<-ifelse(.05-attr.ps[,"p"]>0,.05-
attr.ps[,"p"],99)
index<-(diffs %in%
c(min(diffs),min(diffs[diffs>min(diffs)])))
index
}
# Return range of effects
return (attr.ps[get.bounds(),])
}
with(samp,table(D,Y))
with(samp,apply(table(D,Y),1,prop.table))
samp
with(samp, table(D,Y))
with(samp, prop.table(table(D,Y)))
with(samp, prop.table(table(D,Y), margin = 2))
with(samp,apply(table(D,Y),1,prop.table))
with(samp, prop.table(table(D,Y), margin = 1))
with(samp,apply(table(D,Y),1,prop.table))
with(samp, prop.table(table(Y,D), margin = 1))
attribute(treat=D, out=Y, A=200, data=samp)
treat=D
out=Y
A=200
data=samp
attr.tab<-with(data,table(treat,out)) #
attr.tab
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
attribute<-function(treat,out,A,data){
# Contingency Table of Treatment Status and Outcome
attr.tab<-with(data,table(treat,out)) #
# Matrix of p-values for Attributable effects, A
attr.ps<-
matrix(NA,nc=2,nr=A,dimnames=list(NULL,c("A","p")))
for(i in 1:A){
attr.ps[i,]<-
c(i,fisher.test(attr.tab+matrix(c(0,i,0,-i),2,2))$p)
}
# Find range of effects
get.bounds<-function(){
diffs<-ifelse(.05-attr.ps[,"p"]>0,.05-
attr.ps[,"p"],99)
index<-(diffs %in%
c(min(diffs),min(diffs[diffs>min(diffs)])))
index
}
# Return range of effects
return (attr.ps[get.bounds(),])
}
attribute(treat=D, out=Y, A=200, data=samp)
coef(summary(fit))["D",1:2]
coef(summary(fit))["D",1:2]
set.seed(1234) # For replication
N = 1000 # Population size
Y0 = runif(N) # Potential outcome under control condition
rm(list=ls())
set.seed(1234) # For replication
N = 1000 # Population size
Y0 = runif(N) # Potential outcome under control condition
Y1 = Y0 + 1 # Potential outcome under treatment condition
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise Y = D*Y1 + (1-D)*Y0 # Outcome in population samp = data.frame(D,Y)
ATE = coef(lm(Y~D,data=samp))[2] #same as with(samp,mean(Y[Z==1])-mean(Y[Z==0]))
# SATE with Neyman/Randomization Justified Standard Errors
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0 # Outcome in population samp = data.frame(D,Y)
ATE = coef(lm(Y~D,data=samp))[2] #same as with(samp,mean(Y[Z==1])-mean(Y[Z==0]))
# SATE with Neyman/Randomization Justified Standard Errors
# which are the same as OLS standard errors when no covariates or blocking
library(lmtest)
library(sandwich)
fit<-lm(Y~D,data=samp)
coef(summary(fit))["D",1:2]
rm(list=ls())
set.seed(1234) # For replication
N = 1000 # Population size
Y0 = runif(N) # Potential outcome under control condition
Y1 = Y0 + 1 # Potential outcome under treatment condition
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0 # Outcome in population
samp = data.frame(D,Y)
ATE = coef(lm(Y~D,data=samp))[2] #same as with(samp,mean(Y[Z==1])-mean(Y[Z==0]))
# SATE with Neyman/Randomization Justified Standard Errors
# which are the same as OLS standard errors when no covariates or blocking
library(lmtest)
library(sandwich)
fit<-lm(Y~D,data=samp)
coef(summary(fit))["D",1:2]
ATE.se<-coeftest(fit,vcovHC(fit,type="HC2"))["D",2]
# same as with(samp,
sqrt(var(Y[D==1])/sum(D)+var(Y[D==0])/(n-sum(D))))
# Assess unbiasedness and simulate standard errors
getATE<-function() {
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0
coef(lm(Y~D))[["D"]]
}
manyATEs<-replicate(10000,getATE())
## Unbiasedness: c(ATE=mean(Y1)-mean(Y0), ExpEstATE=mean(manyATEs))
set.seed(1234) # For replication
N = 1000 # Population size
Y0 = runif(N) # Potential outcome under control condition
Y1 = Y0 + 1 # Potential outcome under treatment condition
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0 # Outcome in population
samp = data.frame(D,Y)
ATE = coef(lm(Y~D,data=samp))[2] #same as with(samp,mean(Y[Z==1])-mean(Y[Z==0]))
# SATE with Neyman/Randomization Justified Standard Errors
# which are the same as OLS standard errors when no covariates or blocking
library(lmtest)
library(sandwich)
fit<-lm(Y~D,data=samp)
coef(summary(fit))["D",1:2]
ATE.se<-coeftest(fit,vcovHC(fit,type="HC2"))["D",2]
# same as with(samp,
sqrt(var(Y[D==1])/sum(D)+var(Y[D==0])/(n-sum(D)))
ATE.se<-coeftest(fit,vcovHC(fit,type="HC2"))["D",2]
# same as with(samp,
sqrt(var(Y[D==1])/sum(D)+var(Y[D==0])/(n-sum(D)))
ATE.se<-coeftest(fit,vcovHC(fit,type="HC2"))["D",2]
# same as with(samp,sqrt(var(Y[D==1])/sum(D)+var(Y[D==0])/(n-sum(D)))
# Assess unbiasedness and simulate standard errors
getATE<-function() {
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0
coef(lm(Y~D))[["D"]]
}
manyATEs<-replicate(10000,getATE())
## Unbiasedness: c(ATE=mean(Y1)-mean(Y0), ExpEstATE=mean(manyATEs))
ATE.se<-coeftest(fit,vcovHC(fit,type="HC2"))["D",2]
# same as with(samp,sqrt(var(Y[D==1])/sum(D)+var(Y[D==0])/(n-sum(D)))
# Assess unbiasedness and simulate standard errors
getATE<-function() {
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0
coef(lm(Y~D))[["D"]]
}
manyATEs<-replicate(10000,getATE())
## Unbiasedness: c(ATE=mean(Y1)-mean(Y0), ExpEstATE=mean(manyATEs))
rm(list=ls())
set.seed(1234) # For replication
N = 1000 # Population size
Y0 = runif(N) # Potential outcome under control condition
Y1 = Y0 + 1 # Potential outcome under treatment condition
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0 # Outcome in population
samp = data.frame(D,Y)
ATE = coef(lm(Y~D,data=samp))[2] #same as with(samp,mean(Y[Z==1])-mean(Y[Z==0]))
# SATE with Neyman/Randomization Justified Standard Errors
# which are the same as OLS standard errors when no covariates or blocking
library(lmtest)
library(sandwich)
fit<-lm(Y~D,data=samp)
coef(summary(fit))["D",1:2]
ATE.se<-coeftest(fit,vcovHC(fit,type="HC2"))["D",2]
# same as with(samp,sqrt(var(Y[D==1])/sum(D)+var(Y[D==0])/(n-sum(D)))
# Assess unbiasedness and simulate standard errors
getATE<-function() {
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0
coef(lm(Y~D))[["D"]]
}
manyATEs<-replicate(10000,getATE())
c(ATE=mean(Y1)-mean(Y0), ExpEstATE=mean(manyATEs))
## Standard Error
### True SE formula
V<-var(cbind(Y0,Y1))
varc<-V[1,1]
vart<-V[2,2]
covtc<-V[1,2]
n<-sum(D)
m<-N-n varestATE<-((N-n)/(N-1))*(vart/n) + ((N-m)/(N-1))* (varc/m) + (2/(N-1)) * covtc
### Compare SEs
c(SimulatedSE= sd(manyATEs), TrueSE=sqrt(varestATE), ConservativeSE=ATE.se)
rm(list=ls())
set.seed(1234) # For replication
N = 1000 # Population size
Y0 = runif(N) # Potential outcome under control condition
Y1 = Y0 + 1 # Potential outcome under treatment condition
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0 # Outcome in population
samp = data.frame(D,Y)
ATE = coef(lm(Y~D,data=samp))[2] #same as with(samp,mean(Y[Z==1])-mean(Y[Z==0]))
# SATE with Neyman/Randomization Justified Standard Errors
# which are the same as OLS standard errors when no covariates or blocking
library(lmtest)
library(sandwich)
fit<-lm(Y~D,data=samp)
coef(summary(fit))["D",1:2]
ATE.se<-coeftest(fit,vcovHC(fit,type="HC2"))["D",2]
# same as with(samp,sqrt(var(Y[D==1])/sum(D)+var(Y[D==0])/(n-sum(D)))
# Assess unbiasedness and simulate standard errors
getATE<-function() {
D = sample((1:N)%%2) # Treatment: 1 if treated, 0 otherwise
Y = D*Y1 + (1-D)*Y0
coef(lm(Y~D))[["D"]]
}
manyATEs<-replicate(10000,getATE())
## Unbiasedness:
c(ATE=mean(Y1)-mean(Y0), ExpEstATE=mean(manyATEs))
## Standard Error
### True SE formula
V<-var(cbind(Y0,Y1))
varc<-V[1,1]
vart<-V[2,2]
covtc<-V[1,2]
n<-sum(D)
m<-N-n
varestATE<-((N-n)/(N-1))*(vart/n) + ((N-m)/(N-1))* (varc/m) + (2/(N-1)) * covtc
### Compare SEs
c(SimulatedSE= sd(manyATEs), TrueSE=sqrt(varestATE), ConservativeSE=ATE.se)
