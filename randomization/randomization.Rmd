---
title: "10 Things You Need to Know About Randomization"
author: "Methods Guide Author: Lindsay Dolan"
output: 
  html_document:
    toc: true
---

Abstract
==
This guide will help you design and execute different types of randomization in your experiments. We focus on the big ideas and provide examples and tools that you can use in R.  For why to do randomization see [this methods guide](http://egap.org/methods-guides/10-strategies-figuring-out-if-x-caused-y).


1 Some ways are better than others
==
There are many ways to randomize. The simplest is to flip a coin each time you want to determine whether a given subject gets treatment or not. This ensures that each subject has a .5 probability of receiving the treatment and a .5 probability of not receiving it. Done this way, whether one subject receives the treatment in no way affects whether the next subject receives the treatment, every subject has an equal chance of getting the treatment, and the treatment will be uncorrelated with all confounding factors — at least in expectation.

This is not a bad approach but it has shortcomings. First, using this method, you cannot know in advance how many units will be in treatment and how many in control. If you want to know this, you need some way to do selections so that the different draws are not statistically independent from each other (like drawing names from a hat). Second, you may want to assert control over the exact share of units assigned to treatment and control.  That’s hard to do with a coin. Third, you might want to be able to replicate your randomization to show that there was no funny business. That’s hard to do with coins and hats. Finally, as we show below, there are all sorts of ways to do randomization to improve power and ensure balance in various ways that are very hard to achieve using coins and hats. 

Fortunately though, flexible replicable randomization is very easy to do with freely available software. The following simple R code can, for example, be used to generate a random assignment, specifying the number of units to be treated. Here, N is the number of units you have and m is the number you want to treat. The “seed” makes it possible to replicate the same draw each time you run the code (or you can change the seed for a different draw).[^1]

[^1]: Random number generators are actually pseudo-random because they generate a vector of random numbers based on a small set of initial values, known as a seed state. Random number generators operate this way in order to improve computational speed. However, the series of random numbers generated is as random as you need to it to be for the purposes of random assignment because it is wholly unrelated to the potential outcomes of your subjects.

```{r, error=FALSE, message=FALSE, warning=FALSE, results='hide'}
ra <- function(N,m,seed){
 set.seed(seed)
 assign <- cbind(1:N, 1:N %in% sample(1:N,m))
 return(assign)
 }
ra(100,34,seed=1000)
```

2. Block randomization: You can fix it so that treatment and control groups are balanced
==
It is possible, when randomizing, to specify the balance of particular factors you care about between treatment and control groups, even though it is not possible to specify which particular units are selected for either group and maintain random assignment.

This means that it is possible to specify, for example, that your treatment and control groups contain equal ratios of men to women. In other words, this avoids any randomization that might produce a distinctly male treatment group and a distinctly female control group, or vice-versa.

Why is this desirable? Not because our estimate of the average treatment effect would otherwise be biased, but because it could be really noisy. Suppose that a random assignment happened to generate a very male treatment group and a very female control group. We would observe a correlation between gender and treatment status. If we were to estimate a treatment effect, that treatment effect would still be unbiased because gender did not cause treatment status. However, it would be more difficult to reject the null hypothesis that it was not our treatment but gender that was producing the effect. In short, the imbalance produces a noisy estimate, which makes it more difficult for us to be confident in our estimates.

Block (sometimes called stratified) randomization helps us to rig our experiment so that our treatment and control groups are balanced along important dimensions but are still randomly assigned. Essentially, this type of randomization design constructs multiple mini-experiments: for example, it might take women and randomly assign half to treatment and half to control, and then it would assign half of men to treatment and half to control. This guarantees a gender balance when treatment and control groups are pooled.

The [blockTools package](https://cran.r-project.org/web/packages/blockTools/index.html) is a useful package for conducting block randomization. Let’s start by generating a fake data set for 60 subjects, 36 of whom are male and 24 of whom are female.

Suppose we would like to block on gender. Based on our data, blockTools will generate the smallest possible blocks, each a grouping of two units with the same gender, one of which will be assigned to treatment, and one to control.

```{r, results='hide', error=FALSE, message=FALSE, warning=FALSE}
rm(list=ls())
library(blockTools)
id <- seq(1:60)
female <- sample(c(rep(0, 36), rep(1, 24)))
dta <- as.data.frame(cbind(id, female))
head(dta)
 
set.seed(20140404)
block.out <- block(data = dta, n.tr = 2,id.vars ="id", algorithm="randGreedy",
                   block.vars = "female", verbose=TRUE) # blocks on female
assign.out <- assignment(block.out) # reports treatment assignment
assign.out
 
# now we need to extract, for each unit, its treatment status and block ID
dta$Z <- as.numeric(is.element(1:length(id), as.numeric(as.character(unlist(assign.out$assg[[1]]["Treatment 1"]))))) # creates a vector of treatment assignments
dta$block <- createBlockIDs(block.out, dta, id.var = "id") # creates a vector of block IDs
head(dta)
 
# we can see that we have 30 blocks of 2 in which both units are of the same gender
# and one is assigned to each treatment status
head(table(dta$block, dta$female))
head(table(dta$block, dta$Z))
 
# finally, we can see that there is a gender balance in treatment assignment
table(dta$Z, dta$female)
summary(lm(dta$Z ~ dta$female)) # our p-value is 1
```

You can check the mean of the variable on which you blocked for treatment and control to see that treatment and control groups are in fact perfectly balanced on gender.

3 Factorial designs: You can randomize multiple treatments at the same time without using up power
==
Suppose there are multiple components of a treatment that you want to test. For example, you may want to evaluate the impact of a microfinance program. Two specific treatments might be lending money to women and providing them with training. A factorial design looks at all possible combinations of these treatments: (1) Loans, (2) Training, (3) Loans + Training, and (4) Control. Subjects are then randomly assigned to one of these four conditions.

![](https://raw.githubusercontent.com/egap/methods-guides/master/randomization/factorial-table.png)

Factorial designs are especially useful when evaluating interventions that include a package of treatments. As in the example above, many development interventions come with several arms, and it is sometimes difficult to tell which arms are producing the observed effect. A factorial design separates out these different treatments and also allows us to see the interaction between them.

The following code shows you how to randomize for a factorial design.

```{r, results='hide'}
# a simple way to do a factorial design is to define your different treatment arms
# and specify the number you would like to treat with each treatment arm
my.arms <- c("Loan", "Training")
my.n.arms <- c(40, 40)
factorial.ra <- function(N,arms,n.arms){
  assign <- matrix(NA, nrow=N, ncol=length(arms))
  for (i in 1:length(arms)) {
    assign[,i] <- ifelse(1:N %in% sample(1:N,n.arms[i]),1,0)
  }
  colnames(assign) <- my.arms
  return(assign)
}
assign <- factorial.ra(100,my.arms,my.n.arms)
sum(assign[,"Loan"]==1 & assign[,"Training"]==1)
sum(assign[,"Loan"]==1 & assign[,"Training"]==0)
sum(assign[,"Loan"]==0 & assign[,"Training"]==1)
sum(assign[,"Loan"]==0 & assign[,"Training"]==0)
 
# the following code will allow you to specify the number of subjects you would
# like to receive each combination of treatment arms.
# whereas previously we conceived of two treatment arms--loans and training--
# here we conceive of four treatment arms--loans+training, loans, training, and control.
groupsizes = c(20, 20, 20, 40)
multiple.arms.ra <- function(n, num_arms, groupsizes=NULL){
  indices <- 1:n
  assign <- rep(NA, n)
  if (is.null(groupsizes)){
    for (i in 1:num_arms){
      chosen  <- sample(indices, (n/num_arms))
      assign[chosen] <- paste0("T",i)
      indices <- indices[!indices %in% chosen]
    }
    return(assign)
  }
  for (i in 1:length(groupsizes)){
    chosen <- sample(indices, groupsizes[i])
    assign[chosen] <- paste0("T",i)
    indices <- indices[!indices %in% chosen]
  }
  return(assign)
}
multiple.arms.ra(100, num_arms=4, groupsizes)
# we would assign loans+training to "T1", loans to "T2", training to "T3", and control to "T4"
# in expectation, the factorial randomization code and the multiple arms code will produce identical results
```

