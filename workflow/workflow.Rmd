---
title: "10 Things to Know About Project Workflow"
output:
  html_document:
    theme: journal
    toc: true
---

<!-- title: "10 Things You Need to Know About Project Workflow" -->
<!-- author: "Methods Guide Author: Matthew Lisiecki" -->

1.	People have limited memories
==
There are limits to human memory. Since most experimental research requires at least months if not years of design, monitoring, analysis, and reporting, few researchers can   maintain mental oversight of all of a project’s moving pieces over time. Introduce additional investigators into the mix, and the questions of who did what, when, and why (if not how) multiply and become harder to answer. As replication becomes more important (by the original project team or outside researchers), maintaining a written record of decisions, actions, and questions becomes essential. Bowers and Voors (2016)[^1] provide a framework and steps for improving  project’s workflow; this guide draws upon their paper and upon additional tools aimed at documenting the important choices made by researchers and effectively communicating those choices to the project team.

[^1]: Bowers, J. & Voors, M. 2016. How to Improve Your Relationship With Your Future Self. Revista de Ciencia Política. Vol. 36, Issue 3.

2.	Effective data analysis is aided by coding
==
The best way to leave an easy-to-retrace path (for your future self and others) in data analysis is to produce all outputs through code. Opening Excel to make one change to one table may seem the quickest way to complete the task, but when you are trying to remember what you did months later, you will be glad to have updated your R script or do file to make the desired edit. To maximize re-traceability, leave comments in your code file to explain the purpose of each line, as in the example below.

```{r, eval=FALSE}
# This file produces a plot relating the explanatory variable to the outcome.
## Read the data
thedata <- read.csv(“Data/thedata-15-03-2011.csv”)
## begin writing to the pdf file
please-open-pdf(“g1.pdf”)
please-plot(outcome by explanatory using thedata. red lines
please.)
please-add-a-line(using model1)
## Note to self: a quadratic term does not add to the substance
## model2 <- please-fit(outcome by explanatory+explanatory^2
using thedata
## summary(abs(fitted(model1)-fitted(model2)))
## stop writing to the pdf file
please-close-pdf()
```

Coding has other benefits. It saves time by systematically completing repetitive tasks that could be done manually but with greater time investment. It leads to smoother collaboration by communicating progress and next steps. Finally, it helps researchers avoid making mistakes by combining multiple steps into one file where the order of steps and the relationships among steps is clear.

3.	Coding is communication 1: to your self, to co-investigators, and to the future
==
Data analysis requires a series of decisions, large and small. These decisions will be made both by individual researchers and by research teams. The why and how questions that will arise when you or others attempt to reproduce your work can only be answered if you can remember and communicate about these decisions.

One way to record decisions made during the coding process is to use the **comment** feature of whichever analysis software you are using (for example, lines beginning with * in Stata, # in R are not executed but are understood as notes). Comments are unexecuted text within the script, and can explain the purpose of each line or section to your collaborators or future self. You can see some commented code in the chunk of R code in point 2.

4. Coding is communication 2: to yourself, to co-investigators, and to the future
==
Coding and communication can be linked even tighter by combining them in the same file. Using markup systems  like R Markdown (see section 4 below) or R+LaTeX[^2], you can place a code chunk that produces a table or figure right where that table/figure will be in the document. If you make a change to the code that produces that table/figure, it appears in the document without any additional work. The R code in point 2 starts with ` ```{r codechunk1}` which tells R+markdown that the next bit of text is R code to be executed and ends with ` ``` ` which tells R+markdown to go back to interpreting the text as prose. For example, in markdown one uses two asterisks to make text **bold** (```**like this**```) but two asterisks would confuse R (there is no R command with two asterisks), so the idea of a code chunk allows two or more kinds of text to be mixed in a single document. Coauthors and editors can also review the manuscript together with the tables and figures, rather than scrolling back and forth between the two. When it comes time to produce the final version of the document, the code chunks can be hidden to display only the relevant table/figure.[^3] The idea is to type the document in plain text but that external programs (including R) can compile so that they end up looking like nice, formatted PDFs. You can use Markdown on Windows and Mac OSX, and you can also edit the file in an ordinary text editor. Jupyter notebooks are another recent open source approach to mixing prose text and code text which emphasize the python language but which can also include R.[^4]

[^2]: Called, anachronistically, Sweave

[^3]: Note that all of the EGAP methods guides that produce figures or tables are produced this way (see https://github.com/egap/methods-guides)

[^4]: There are many ways to type text that includes code such that parenthesis are automatically closed, spelling is checked, or even help is provided about the code itself. RStudio is an integrated development environment (IDE) that includes a nice editor. Some of us use older tools that are more widespread such as vim, or eMacs. Others any of the contemporary improvements on those old tools such as Atom.

